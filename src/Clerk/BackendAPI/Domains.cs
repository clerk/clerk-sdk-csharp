//------------------------------------------------------------------------------
// <auto-generated>
// This code was generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
namespace Clerk.BackendAPI
{
    using Clerk.BackendAPI.Hooks;
    using Clerk.BackendAPI.Models.Components;
    using Clerk.BackendAPI.Models.Errors;
    using Clerk.BackendAPI.Models.Operations;
    using Clerk.BackendAPI.Utils;
    using Clerk.BackendAPI.Utils.Retries;
    using Newtonsoft.Json;
    using System;
    using System.Collections.Generic;
    using System.Net.Http;
    using System.Net.Http.Headers;
    using System.Threading.Tasks;

    public interface IDomains
    {
        /// <summary>
        /// List all instance domains.
        /// </summary>
        /// <remarks>
        /// Use this endpoint to get a list of all domains for an instance.<br/>
        /// The response will contain the primary domain for the instance and any satellite domains. Each domain in the response contains information about the URLs where Clerk operates and the required CNAME targets.
        /// </remarks>
        /// <param name="retryConfig">The retry configuration to use for this operation.</param>
        /// <returns>An awaitable task that returns a <see cref="ListDomainsResponse"/> response envelope when completed.</returns>
        /// <exception cref="HttpRequestException">The HTTP request failed due to network issues.</exception>
        /// <exception cref="ResponseValidationException">The response body could not be deserialized.</exception>
        /// <exception cref="SDKError">Default API Exception. Thrown when the API returns a 4XX or 5XX response.</exception>
        public  Task<ListDomainsResponse> ListAsync(RetryConfig? retryConfig = null);

        /// <summary>
        /// Add a domain.
        /// </summary>
        /// <remarks>
        /// Add a new domain for your instance.<br/>
        /// Useful in the case of multi-domain instances, allows adding satellite domains to an instance.<br/>
        /// The new domain must have a `name`. The domain name can contain the port for development instances, like `localhost:3000`.<br/>
        /// At the moment, instances can have only one primary domain, so the `is_satellite` parameter must be set to `true`.<br/>
        /// If you're planning to configure the new satellite domain to run behind a proxy, pass the `proxy_url` parameter accordingly.
        /// </remarks>
        /// <param name="request">A <see cref="AddDomainRequestBody"/> parameter.</param>
        /// <param name="retryConfig">The retry configuration to use for this operation.</param>
        /// <returns>An awaitable task that returns a <see cref="AddDomainResponse"/> response envelope when completed.</returns>
        /// <exception cref="HttpRequestException">The HTTP request failed due to network issues.</exception>
        /// <exception cref="ResponseValidationException">The response body could not be deserialized.</exception>
        /// <exception cref="ClerkErrors">Request was not successful. Thrown when the API returns a 400, 402 or 422 response.</exception>
        /// <exception cref="SDKError">Default API Exception. Thrown when the API returns a 4XX or 5XX response.</exception>
        public  Task<AddDomainResponse> AddAsync(AddDomainRequestBody? request = null, RetryConfig? retryConfig = null);

        /// <summary>
        /// Delete a satellite domain.
        /// </summary>
        /// <remarks>
        /// Deletes a satellite domain for the instance.<br/>
        /// It is currently not possible to delete the instance's primary domain.
        /// </remarks>
        /// <param name="domainId">The ID of the domain that will be deleted. Must be a satellite domain.</param>
        /// <param name="retryConfig">The retry configuration to use for this operation.</param>
        /// <returns>An awaitable task that returns a <see cref="DeleteDomainResponse"/> response envelope when completed.</returns>
        /// <exception cref="ArgumentNullException">The required parameter <paramref name="domainId"/> is null.</exception>
        /// <exception cref="HttpRequestException">The HTTP request failed due to network issues.</exception>
        /// <exception cref="ResponseValidationException">The response body could not be deserialized.</exception>
        /// <exception cref="ClerkErrors">Request was not successful. Thrown when the API returns a 403 or 404 response.</exception>
        /// <exception cref="SDKError">Default API Exception. Thrown when the API returns a 4XX or 5XX response.</exception>
        public  Task<DeleteDomainResponse> DeleteAsync(string domainId, RetryConfig? retryConfig = null);

        /// <summary>
        /// Update a domain.
        /// </summary>
        /// <remarks>
        /// The `proxy_url` can be updated only for production instances.<br/>
        /// Update one of the instance's domains. Both primary and satellite domains can be updated.<br/>
        /// If you choose to use Clerk via proxy, use this endpoint to specify the `proxy_url`.<br/>
        /// Whenever you decide you'd rather switch to DNS setup for Clerk, simply set `proxy_url`<br/>
        /// to `null` for the domain. When you update a production instance's primary domain name,<br/>
        /// you have to make sure that you've completed all the necessary setup steps for DNS and<br/>
        /// emails to work. Expect downtime otherwise. Updating a primary domain's name will also<br/>
        /// update the instance's home origin, affecting the default application paths.
        /// </remarks>
        /// <param name="domainId">The ID of the domain that will be updated.</param>
        /// <param name="requestBody">A <see cref="UpdateDomainRequestBody"/> parameter.</param>
        /// <param name="retryConfig">The retry configuration to use for this operation.</param>
        /// <returns>An awaitable task that returns a <see cref="UpdateDomainResponse"/> response envelope when completed.</returns>
        /// <exception cref="ArgumentNullException">One of <paramref name="domainId"/> or <paramref name="requestBody"/> is null.</exception>
        /// <exception cref="HttpRequestException">The HTTP request failed due to network issues.</exception>
        /// <exception cref="ResponseValidationException">The response body could not be deserialized.</exception>
        /// <exception cref="ClerkErrors">Request was not successful. Thrown when the API returns a 400, 404 or 422 response.</exception>
        /// <exception cref="SDKError">Default API Exception. Thrown when the API returns a 4XX or 5XX response.</exception>
        public  Task<UpdateDomainResponse> UpdateAsync(
            string domainId,
            UpdateDomainRequestBody requestBody,
            RetryConfig? retryConfig = null
        );
    }

    public class Domains: IDomains
    {
        /// <summary>
        /// SDK Configuration.
        /// <see cref="SDKConfig"/>
        /// </summary>
        public SDKConfig SDKConfiguration { get; private set; }

        public Domains(SDKConfig config)
        {
            SDKConfiguration = config;
        }

        /// <summary>
        /// List all instance domains.
        /// </summary>
        /// <remarks>
        /// Use this endpoint to get a list of all domains for an instance.<br/>
        /// The response will contain the primary domain for the instance and any satellite domains. Each domain in the response contains information about the URLs where Clerk operates and the required CNAME targets.
        /// </remarks>
        /// <param name="retryConfig">The retry configuration to use for this operation.</param>
        /// <returns>An awaitable task that returns a <see cref="ListDomainsResponse"/> response envelope when completed.</returns>
        /// <exception cref="HttpRequestException">The HTTP request failed due to network issues.</exception>
        /// <exception cref="ResponseValidationException">The response body could not be deserialized.</exception>
        /// <exception cref="SDKError">Default API Exception. Thrown when the API returns a 4XX or 5XX response.</exception>
        public async  Task<ListDomainsResponse> ListAsync(RetryConfig? retryConfig = null)
        {
            string baseUrl = this.SDKConfiguration.GetTemplatedServerUrl();
            var urlString = baseUrl + "/domains";

            var httpRequest = new HttpRequestMessage(HttpMethod.Get, urlString);
            httpRequest.Headers.Add("user-agent", SDKConfiguration.UserAgent);

            if (SDKConfiguration.SecuritySource != null)
            {
                httpRequest = new SecurityMetadata(SDKConfiguration.SecuritySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext(SDKConfiguration, baseUrl, "ListDomains", null, SDKConfiguration.SecuritySource);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);
            if (retryConfig == null)
            {
                if (this.SDKConfiguration.RetryConfig != null)
                {
                    retryConfig = this.SDKConfiguration.RetryConfig;
                }
                else
                {
                    var backoff = new BackoffStrategy(
                        initialIntervalMs: 500L,
                        maxIntervalMs: 60000L,
                        maxElapsedTimeMs: 3600000L,
                        exponent: 1.5
                    );
                    retryConfig = new RetryConfig(
                        strategy: RetryConfig.RetryStrategy.BACKOFF,
                        backoff: backoff,
                        retryConnectionErrors: true
                    );
                }
            }

            List<string> statusCodes = new List<string>
            {
                "5XX",
            };

            Func<Task<HttpResponseMessage>> retrySend = async () =>
            {
                var _httpRequest = await SDKConfiguration.Client.CloneAsync(httpRequest);
                return await SDKConfiguration.Client.SendAsync(_httpRequest);
            };
            var retries = new Clerk.BackendAPI.Utils.Retries.Retries(retrySend, retryConfig, statusCodes);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await retries.Run();
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception _hookError)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, _hookError);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    Models.Components.Domains obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<Models.Components.Domains>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into Models.Components.Domains.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new ListDomainsResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.Domains = obj;
                    return response;
                }

                throw new Models.Errors.SDKError("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500)
            {
                throw new Models.Errors.SDKError("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.SDKError("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }

            throw new Models.Errors.SDKError("Unknown status code received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
        }


        /// <summary>
        /// Add a domain.
        /// </summary>
        /// <remarks>
        /// Add a new domain for your instance.<br/>
        /// Useful in the case of multi-domain instances, allows adding satellite domains to an instance.<br/>
        /// The new domain must have a `name`. The domain name can contain the port for development instances, like `localhost:3000`.<br/>
        /// At the moment, instances can have only one primary domain, so the `is_satellite` parameter must be set to `true`.<br/>
        /// If you're planning to configure the new satellite domain to run behind a proxy, pass the `proxy_url` parameter accordingly.
        /// </remarks>
        /// <param name="request">A <see cref="AddDomainRequestBody"/> parameter.</param>
        /// <param name="retryConfig">The retry configuration to use for this operation.</param>
        /// <returns>An awaitable task that returns a <see cref="AddDomainResponse"/> response envelope when completed.</returns>
        /// <exception cref="HttpRequestException">The HTTP request failed due to network issues.</exception>
        /// <exception cref="ResponseValidationException">The response body could not be deserialized.</exception>
        /// <exception cref="ClerkErrors">Request was not successful. Thrown when the API returns a 400, 402 or 422 response.</exception>
        /// <exception cref="SDKError">Default API Exception. Thrown when the API returns a 4XX or 5XX response.</exception>
        public async  Task<AddDomainResponse> AddAsync(
            AddDomainRequestBody? request = null,
            RetryConfig? retryConfig = null
        )
        {
            string baseUrl = this.SDKConfiguration.GetTemplatedServerUrl();
            var urlString = baseUrl + "/domains";

            var httpRequest = new HttpRequestMessage(HttpMethod.Post, urlString);
            httpRequest.Headers.Add("user-agent", SDKConfiguration.UserAgent);

            var serializedBody = RequestBodySerializer.Serialize(request, "Request", "json", false, true);
            if (serializedBody != null)
            {
                httpRequest.Content = serializedBody;
            }

            if (SDKConfiguration.SecuritySource != null)
            {
                httpRequest = new SecurityMetadata(SDKConfiguration.SecuritySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext(SDKConfiguration, baseUrl, "AddDomain", null, SDKConfiguration.SecuritySource);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);
            if (retryConfig == null)
            {
                if (this.SDKConfiguration.RetryConfig != null)
                {
                    retryConfig = this.SDKConfiguration.RetryConfig;
                }
                else
                {
                    var backoff = new BackoffStrategy(
                        initialIntervalMs: 500L,
                        maxIntervalMs: 60000L,
                        maxElapsedTimeMs: 3600000L,
                        exponent: 1.5
                    );
                    retryConfig = new RetryConfig(
                        strategy: RetryConfig.RetryStrategy.BACKOFF,
                        backoff: backoff,
                        retryConnectionErrors: true
                    );
                }
            }

            List<string> statusCodes = new List<string>
            {
                "5XX",
            };

            Func<Task<HttpResponseMessage>> retrySend = async () =>
            {
                var _httpRequest = await SDKConfiguration.Client.CloneAsync(httpRequest);
                return await SDKConfiguration.Client.SendAsync(_httpRequest);
            };
            var retries = new Clerk.BackendAPI.Utils.Retries.Retries(retrySend, retryConfig, statusCodes);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await retries.Run();
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception _hookError)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, _hookError);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    Domain obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<Domain>(httpResponseBody, NullValueHandling.Include);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into Domain.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new AddDomainResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.Domain = obj;
                    return response;
                }

                throw new Models.Errors.SDKError("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(new List<int>{400, 402, 422}.Contains(responseStatusCode))
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ClerkErrorsPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<ClerkErrorsPayload>(httpResponseBody, NullValueHandling.Include);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ClerkErrorsPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    throw new ClerkErrors(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.SDKError("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500)
            {
                throw new Models.Errors.SDKError("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.SDKError("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }

            throw new Models.Errors.SDKError("Unknown status code received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
        }


        /// <summary>
        /// Delete a satellite domain.
        /// </summary>
        /// <remarks>
        /// Deletes a satellite domain for the instance.<br/>
        /// It is currently not possible to delete the instance's primary domain.
        /// </remarks>
        /// <param name="domainId">The ID of the domain that will be deleted. Must be a satellite domain.</param>
        /// <param name="retryConfig">The retry configuration to use for this operation.</param>
        /// <returns>An awaitable task that returns a <see cref="DeleteDomainResponse"/> response envelope when completed.</returns>
        /// <exception cref="ArgumentNullException">The required parameter <paramref name="domainId"/> is null.</exception>
        /// <exception cref="HttpRequestException">The HTTP request failed due to network issues.</exception>
        /// <exception cref="ResponseValidationException">The response body could not be deserialized.</exception>
        /// <exception cref="ClerkErrors">Request was not successful. Thrown when the API returns a 403 or 404 response.</exception>
        /// <exception cref="SDKError">Default API Exception. Thrown when the API returns a 4XX or 5XX response.</exception>
        public async  Task<DeleteDomainResponse> DeleteAsync(string domainId, RetryConfig? retryConfig = null)
        {
            if (domainId == null) throw new ArgumentNullException(nameof(domainId));

            var request = new DeleteDomainRequest()
            {
                DomainId = domainId,
            };

            string baseUrl = this.SDKConfiguration.GetTemplatedServerUrl();
            var urlString = URLBuilder.Build(baseUrl, "/domains/{domain_id}", request, null);

            var httpRequest = new HttpRequestMessage(HttpMethod.Delete, urlString);
            httpRequest.Headers.Add("user-agent", SDKConfiguration.UserAgent);

            if (SDKConfiguration.SecuritySource != null)
            {
                httpRequest = new SecurityMetadata(SDKConfiguration.SecuritySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext(SDKConfiguration, baseUrl, "DeleteDomain", null, SDKConfiguration.SecuritySource);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);
            if (retryConfig == null)
            {
                if (this.SDKConfiguration.RetryConfig != null)
                {
                    retryConfig = this.SDKConfiguration.RetryConfig;
                }
                else
                {
                    var backoff = new BackoffStrategy(
                        initialIntervalMs: 500L,
                        maxIntervalMs: 60000L,
                        maxElapsedTimeMs: 3600000L,
                        exponent: 1.5
                    );
                    retryConfig = new RetryConfig(
                        strategy: RetryConfig.RetryStrategy.BACKOFF,
                        backoff: backoff,
                        retryConnectionErrors: true
                    );
                }
            }

            List<string> statusCodes = new List<string>
            {
                "5XX",
            };

            Func<Task<HttpResponseMessage>> retrySend = async () =>
            {
                var _httpRequest = await SDKConfiguration.Client.CloneAsync(httpRequest);
                return await SDKConfiguration.Client.SendAsync(_httpRequest);
            };
            var retries = new Clerk.BackendAPI.Utils.Retries.Retries(retrySend, retryConfig, statusCodes);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await retries.Run();
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception _hookError)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, _hookError);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    DeletedObject obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<DeletedObject>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into DeletedObject.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new DeleteDomainResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.DeletedObject = obj;
                    return response;
                }

                throw new Models.Errors.SDKError("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(new List<int>{403, 404}.Contains(responseStatusCode))
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ClerkErrorsPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<ClerkErrorsPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ClerkErrorsPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    throw new ClerkErrors(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.SDKError("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500)
            {
                throw new Models.Errors.SDKError("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.SDKError("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }

            throw new Models.Errors.SDKError("Unknown status code received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
        }


        /// <summary>
        /// Update a domain.
        /// </summary>
        /// <remarks>
        /// The `proxy_url` can be updated only for production instances.<br/>
        /// Update one of the instance's domains. Both primary and satellite domains can be updated.<br/>
        /// If you choose to use Clerk via proxy, use this endpoint to specify the `proxy_url`.<br/>
        /// Whenever you decide you'd rather switch to DNS setup for Clerk, simply set `proxy_url`<br/>
        /// to `null` for the domain. When you update a production instance's primary domain name,<br/>
        /// you have to make sure that you've completed all the necessary setup steps for DNS and<br/>
        /// emails to work. Expect downtime otherwise. Updating a primary domain's name will also<br/>
        /// update the instance's home origin, affecting the default application paths.
        /// </remarks>
        /// <param name="domainId">The ID of the domain that will be updated.</param>
        /// <param name="requestBody">A <see cref="UpdateDomainRequestBody"/> parameter.</param>
        /// <param name="retryConfig">The retry configuration to use for this operation.</param>
        /// <returns>An awaitable task that returns a <see cref="UpdateDomainResponse"/> response envelope when completed.</returns>
        /// <exception cref="ArgumentNullException">One of <paramref name="domainId"/> or <paramref name="requestBody"/> is null.</exception>
        /// <exception cref="HttpRequestException">The HTTP request failed due to network issues.</exception>
        /// <exception cref="ResponseValidationException">The response body could not be deserialized.</exception>
        /// <exception cref="ClerkErrors">Request was not successful. Thrown when the API returns a 400, 404 or 422 response.</exception>
        /// <exception cref="SDKError">Default API Exception. Thrown when the API returns a 4XX or 5XX response.</exception>
        public async  Task<UpdateDomainResponse> UpdateAsync(
            string domainId,
            UpdateDomainRequestBody requestBody,
            RetryConfig? retryConfig = null
        )
        {
            if (domainId == null) throw new ArgumentNullException(nameof(domainId));
            if (requestBody == null) throw new ArgumentNullException(nameof(requestBody));

            var request = new UpdateDomainRequest()
            {
                DomainId = domainId,
                RequestBody = requestBody,
            };

            string baseUrl = this.SDKConfiguration.GetTemplatedServerUrl();
            var urlString = URLBuilder.Build(baseUrl, "/domains/{domain_id}", request, null);

            var httpRequest = new HttpRequestMessage(HttpMethod.Patch, urlString);
            httpRequest.Headers.Add("user-agent", SDKConfiguration.UserAgent);

            var serializedBody = RequestBodySerializer.Serialize(request, "RequestBody", "json", false, false);
            if (serializedBody != null)
            {
                httpRequest.Content = serializedBody;
            }

            if (SDKConfiguration.SecuritySource != null)
            {
                httpRequest = new SecurityMetadata(SDKConfiguration.SecuritySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext(SDKConfiguration, baseUrl, "UpdateDomain", null, SDKConfiguration.SecuritySource);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);
            if (retryConfig == null)
            {
                if (this.SDKConfiguration.RetryConfig != null)
                {
                    retryConfig = this.SDKConfiguration.RetryConfig;
                }
                else
                {
                    var backoff = new BackoffStrategy(
                        initialIntervalMs: 500L,
                        maxIntervalMs: 60000L,
                        maxElapsedTimeMs: 3600000L,
                        exponent: 1.5
                    );
                    retryConfig = new RetryConfig(
                        strategy: RetryConfig.RetryStrategy.BACKOFF,
                        backoff: backoff,
                        retryConnectionErrors: true
                    );
                }
            }

            List<string> statusCodes = new List<string>
            {
                "5XX",
            };

            Func<Task<HttpResponseMessage>> retrySend = async () =>
            {
                var _httpRequest = await SDKConfiguration.Client.CloneAsync(httpRequest);
                return await SDKConfiguration.Client.SendAsync(_httpRequest);
            };
            var retries = new Clerk.BackendAPI.Utils.Retries.Retries(retrySend, retryConfig, statusCodes);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await retries.Run();
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception _hookError)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, _hookError);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    Domain obj;
                    try
                    {
                        obj = ResponseBodyDeserializer.DeserializeNotNull<Domain>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into Domain.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    var response = new UpdateDomainResponse()
                    {
                        HttpMeta = new Models.Components.HTTPMetadata()
                        {
                            Response = httpResponse,
                            Request = httpRequest
                        }
                    };
                    response.Domain = obj;
                    return response;
                }

                throw new Models.Errors.SDKError("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(new List<int>{400, 404, 422}.Contains(responseStatusCode))
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var httpResponseBody = await httpResponse.Content.ReadAsStringAsync();
                    ClerkErrorsPayload payload;
                    try
                    {
                        payload = ResponseBodyDeserializer.DeserializeNotNull<ClerkErrorsPayload>(httpResponseBody, NullValueHandling.Ignore);
                    }
                    catch (Exception ex)
                    {
                        throw new ResponseValidationException("Failed to deserialize response body into ClerkErrorsPayload.", httpRequest, httpResponse, httpResponseBody, ex);
                    }

                    throw new ClerkErrors(payload, httpRequest, httpResponse, httpResponseBody);
                }

                throw new Models.Errors.SDKError("Unknown content type received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500)
            {
                throw new Models.Errors.SDKError("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }
            else if(responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.SDKError("API error occurred", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
            }

            throw new Models.Errors.SDKError("Unknown status code received", httpRequest, httpResponse, await httpResponse.Content.ReadAsStringAsync());
        }

    }
}